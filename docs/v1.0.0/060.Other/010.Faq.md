---
title: Faq
date: 2022-06-21 11:08:44
permalink: /pages/2bac63/
---
1. What should I do when there are some requirements that the API provided by EE does not support? It doesn't matter, the author has already helped the masters to think of the best solution, please check here: [Hybrid query](hybrid-query.md)

2. During the trial process, an error is reported: java.lang.reflect.UndeclaredThrowableException
````
Caused by: [daily_document] ElasticsearchStatusException[Elasticsearch exception [type=index_not_found_exception, reason=no such index [daily_document]]]
````
If your error message and cause are the same as above, please check whether the index name is configured correctly, check the global configuration, and the annotation configuration. If the configuration is correct, the index may not exist. You can use the es-head visualization tool to check whether the specified index already exists. , if there is no such index, it can be quickly created through the API provided by EE.

3. Dependency conflict<br />Although the EE framework is lightweight enough, and I try to avoid using too many other dependencies during the development process, it is still difficult to guarantee that there is a very small probability that there will be a dependency conflict with the host project. Dependency conflicts can be resolved by removing duplicate dependencies or unifying the version numbers of dependencies. All possible conflicting dependencies of EE are as follows:
````xml
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
          <version>1.18.12</version>
        </dependency>
        <dependency>
            <groupId>org.elasticsearch.client</groupId>
            <artifactId>elasticsearch-rest-high-level-client</artifactId>
            <version>7.10.1</version>
        </dependency>
        <dependency>
            <groupId>org.elasticsearch</groupId>
            <artifactId>elasticsearch</artifactId>
            <version>7.10.1</version>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
            <version>1.2.79</version>
        </dependency>
        <dependency>
             <groupId>commons-codec</groupId>
             <artifactId>commons-codec</artifactId>
             <version>1.6</version>
        </dependency>
````

4. The error NoSuchMethod is reported, and the error message is roughly as follows:
> EasyEsException: no such method:
at ExceptionUtils.eee(ExceptionUtils.java:36)
at BaseCache.lambda$setterMethod$5(BaseCache.java:94)
at java.util.Optional.orElseThrow(Optional.java:290)

Usually, there is no id field in your entity class Model. You can copy the example I provided below, choose one of the two as needed, and add an id field. The field type is not limited, but the field name must be called id.
````java
// Use the Id value automatically generated by es
private String id;

// If you specify the value of your id yourself, for example, use the value of the id in MySQL, please add a comment
@TableId(type = IdType.CUSTOMIZE)
private Long id;
````
Of course, there are also some users who have reported that the ID has been added or an error is reported. You might as well remove the value="id" in the @TableId(value="id") annotation, because the id field is named _id in es. I have already explained the difference. The masking process is done in the framework, so the user does not need to specify the value. The easiest way is to directly copy the code I provided above.

5. Can't find the data using wrapper.eq(xx::getXX, "query content")?
   eq corresponds to the TermQuery() of es, which can only be queried when the index type of the queried field is keyword. If the index type of the queried field is text, then the field will not be queried by eq. You may wish to look at yourself before using it. If you need word segmentation matching, set the index type of the field as text type, and then use wrapper.match(), wrapper.queryString() and other methods to query; if you need exact matching, you can use the index The field type is established as the keyword type, and then use wrapper.eq() to query; if the same field needs to be queried by exact match and by word segmentation, its index type can be created as keyword&text type, and it is regarded as keyword When querying by type, you need to pass in the field name as "field name.keyword". When querying it as a text type, you can directly use the field name. Or you may wish to make this field redundant, add a new field, the value is consistent with the field, one index uses keyword, one uses text type, so that it can be solved perfectly. For es, it supports PB-level data and adds a redundancy. fields, the performance impact is minimal.

:::tip Tips
In the use of the framework, it is inevitable that exceptions will occur due to various reasons. We do not rule out the defects of the framework itself, but most of the functions currently released are relatively stable and have test case coverage and a large number of users have verified the production environment. , Most of the time, users do not use the document and play freely, which leads to some problems. Such users are usually lazy, and when they encounter a big problem, they immediately come to the group to ask, or complain about the framework garbage, and then we help The investigation and solution finally found that the xx place was not used according to the document, but was messing around. We are also very helpless. After all, the energy and time of open source are relatively limited. We want to spend time on the cutting edge, such as collecting real bugs and iterating. Instead of wasting time in these useless places.
Therefore, we still hope that users can read the document more before using it. If you encounter problems, you might as well start with the document and see how the DEMO we provide is written. Break the point to find the reason, look at the source code analysis and analysis, and have gone through these steps , If you still can't solve it, you can ask questions in the Q&A group again. This is the basic quality of a code farmer, and it is of great help to improve your own technical level. If you encounter problems, throw them out, and over time, solve and analyze problems independently The ability of the device will get worse and worse. If things go on like this, if one day you use a certain open source product, and no one answers your questions, what will you do?
:::